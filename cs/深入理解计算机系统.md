# 记录读<<深入理解计算机系统>>这本书的笔记
---

## 第一章
1. 根据机械原理，较大的存储设备要比较小的运行得慢。
2. 上层的存储器是下层存储器的缓存。
3. 层次结构中的每一层都缓存来自较低一层的数据对象。

## 第八章
> 1. 用户模式和内核模式

- 为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间。

- 处理器通常是用某个控制寄存器中的一个***模式位(mode bit)***来提供这种功能的，该寄存器描述了进程当前享有的特权。


- 当设置了模式位时，进程就运行在***内核模式***中了***(有时叫超级用户模式)***。

- 一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。

- 没有设置模式位时，进程就运行在***用户模式***中，用户模式中的进程不允许执行***特权操作***，比如***改变模式位、发起I/O操作***

- 用户程序必须通过***系统调用***(**system call**)访问内核代码和数据

- 运行应用程序的代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的***唯一方法***是通过诸如***中断、故障、陷入系统调用***这样的***异常***

- 当异常发生时，控制传递到异常处理程序，处理器模式从用户模式变成**内核模式**。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式

---
>> Linux 提供了一种聪明的机制，叫做/proc文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多**内核数据结构**的内容输出为一个**用户程序可读的文本文件**的层次结构。

---

> 2. 上下文切换

- 操作系统内核使用一种称为**上下文切换**(**context switch**)的较高层形式的异常控制流来实现多任务。

- 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做**调度**(**scheduling**)

- 进程A想要读取磁盘内容，通过read系统调用发起磁盘IO，内核中的**陷阱处理程序**请求来自磁盘控制器的DMA传输，并且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。由于磁盘IO比较耗时（数量为几十毫秒），所以内核执行上下文切换，切换A到别的进程执行，而不是在这个间歇时间内等待，什么都不做。注意在切换之前，内核正代表A进程在用户模式下执行指令（即没有单独的内核进程）。在切换的第一部分中，内核代表进程A在内核模式下执行指令。然后在某一时刻，他开始代表进程B（仍然是内核模式下）执行指令。在切换之后，内核代表进程B在用户模式下执行指令。随后，进程B在用户模式下运行一会儿，直到磁盘发出一个中断信号，表示数据已经从磁盘传送到了内存。内核判定进程B已经运行了足够长的时间，就执行一个从进程B到进程A的上下文切换，将控制返回给进程A中紧随在系统调用read之后的那条指令。进程A继续运行，直到下一次异常发生，依次类推。
